# ES6

数组扩展，对象的扩展，函数扩展，Symbol 新的原始数据类型

1. 数组扩展
   1- ... 复制数组 、合并数组 、与解构赋值结合、字符串.......

   ```JS
   let myarr=[1,2,3,4,5,6]
   let arr1=[1,2,3];
   let arr2=[4,5,6];
   console.log([...arr1]);  //复制数组
   console.log([...arr1,...arr2])  //合并数组，浅拷贝
   let [a,b,...c]=myarr;   //1,2,[3,4,5,6]  与解构赋值结合
   ```

   2- Array.from 用于将两类对象转为真正的数组

   3- Array.of 新建数组，弥补之前的 Array，Array(3)会被认为是一个包含 3 个元素的空数组，而不是一个数组的唯一元素

   4- find findIndex()
   findLast findLastIndex() 从后面开始找

   ```JS
   let arr=[11,12,13,14,15]
   let res=arr.find(function(item){
    return item>13
   })
   console.log(res)  //13
   let res=arr.findIndex(function(item){
    return item>13
   })
   console.log(res)  //4
   ```

   5- fill 使用给定值，填充一个数组

2. 对象扩展
   1- 对象简写

   ```JS
   let name="ww"
   let obj={
    name,  //如果key值和变量值一样可简写，否则就是name:name,
   }
   ```

   2- 对象属性表达式 Object.assign() Object.is()

   - Object.assign() 用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）

   ```JS
   const target = { a: 1 };
   const source1 = { b: 2 };
   const source2 = { c: 3 };
   Object.assign(target, source1, source2);
   target // {a:1, b:2, c:3}
   ```

   注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。
   如果只有一个参数，Object.assign 会直接返回该参数。
   如果该参数不是对象，则会先转成对象，然后返回。
   由于 undefined 和 null 无法转成对象，所以如果它们作为参数，就会报错。
   Object.assign 拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。

   - Object.is() 它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。
     区别：一是判断+0 不等于-0，二是判断 NaN 等于自身。

3. 函数的扩展
   1- 参数默认值
   2- rest 参数 剩余参数

   ```JS
   function test(...data){
    console.log(data)
   }
   test(1,2,3,4,5,6)
   ```

   3- name 属性
   4- 箭头函数：写法简洁

   ```JS
   let test=()=>"111"
   console.log(test())
   ```

   1. 只有 return 可以省略
   2. 如果返回对象需要注意
   3. 如果只有一个参数，可以省略()
   4. 无法访问 arguments,无法 new

   5- 模糊搜索

4. Symbol 新的原始数据类型，表示独一无二的值

   ```JS
   let s1=Symbol()   //生成了一个symbol类型数据
   ```

   1. 不能进行运算
   2. 显示调用 toString()
   3. 隐式转换 Boolean
   4. 独一无二的使用，对象的属性

   ```JS
   let keys={
    name:Symbol("name"), //传参，标记一下，区分每一个属性
    age:Synbol()
   }
   let obj={
    [keys.name]:"ww",
    [keys.age]:18,
   }
   ```

   5. 不能 for in 循环遍历 Object.getOwnProperSymbols() 查找 Symbol 属性

   ```JS
   Reflect.ownKeys(obj).foeEach(item=>{
    console.log(item,obj[item])
   })
   ```

   6. 作为常量
